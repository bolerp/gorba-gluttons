Отлично! Переход от визуального MVP к рабочему продукту — самый волнующий этап. Сейчас мы пошагово оживим все ваши заглушки, подключив их к блокчейну Gorbagana.
Вот подробная инструкция по интеграции, разбитая на логические шаги. Мы будем использовать популярный и надежный стек: @solana/wallet-adapter для работы с кошельками и @solana/web3.js для взаимодействия с блокчейном.
Архитектурный ликбез: Как всё связано
Прежде чем писать код, давайте еще раз закрепим, кто за что отвечает:
1. Frontend (ваш сайт на Next.js):
   * Показывает UI (кнопки, монстра, лидерборд).
   * Запрашивает у кошелька разрешение на подключение.
   * Запрашивает у кошелька подпись на транзакцию.
   * Читает публичные данные с блокчейна (баланс).
   * Общается с вашим бэкендом для получения данных лидерборда и регистрации рефералов.
2. Wallet (Backpack, Phantom и др.):
   * Безопасно хранит приватные ключи пользователя.
   * Предоставляет фронтенду публичный адрес пользователя.
   * Показывает пользователю окно для подтверждения (подписи) транзакций. Ваш сайт никогда не видит приватный ключ.
3. Backend (ваш сервер на Node.js):
   * "Слушает" блокчейн, индексирует нужные транзакции.
   * Считает очки, бонусы, ведет статистику.
   * Предоставляет готовые данные (лидерборд) фронтенду через API.
________________
Подготовка: Установка необходимых пакетов
Откройте терминал в папке вашего Next.js проекта и установите всё необходимое:


Bash




npm install @solana/wallet-adapter-react @solana/wallet-adapter-react-ui @solana/wallet-adapter-base @solana/wallet-adapter-wallets @solana/web3.js

или


Bash




yarn add @solana/wallet-adapter-react @solana/wallet-adapter-react-ui @solana/wallet-adapter-base @solana/wallet-adapter-wallets @solana/web3.js

________________
Шаг 1: Настройка "шлюза" в блокчейн (Wallet Provider)
Это фундаментальный шаг. Мы "оборачиваем" всё ваше приложение в специальные компоненты (провайдеры), которые дают любой части сайта доступ к кошельку и сети.
Откройте файл pages/_app.js (или _app.tsx) и приведите его к следующему виду:


JavaScript




import { WalletAdapterNetwork } from '@solana/wallet-adapter-base';
import { ConnectionProvider, WalletProvider } from '@solana/wallet-adapter-react';
import { WalletModalProvider, WalletMultiButton } from '@solana/wallet-adapter-react-ui';
import { PhantomWalletAdapter, SolflareWalletAdapter } from '@solana/wallet-adapter-wallets';
import { useMemo } from 'react';

// Подключаем стили для кнопки и модального окна кошелька
require('@solana/wallet-adapter-react-ui/styles.css');
// Ваши глобальные стили
require('../styles/globals.css');

function MyApp({ Component, pageProps }) {
   // URL RPC-эндпоинта сети Gorbagana. Замените на актуальный.
   // Пример: 'https://rpc.gorbaganachain.xyz/'
   const endpoint = useMemo(() => 'https://devnet.solana.com', []); // !!! ЗАМЕНИТЕ НА RPC GORBAGANA !!!

   // Список кошельков, которые мы будем поддерживать
   const wallets = useMemo(
       () => [
           new PhantomWalletAdapter(),
           new SolflareWalletAdapter(),
       ],
       []
   );

   return (
       <ConnectionProvider endpoint={endpoint}>
           <WalletProvider wallets={wallets} autoConnect>
               <WalletModalProvider>
                   {/* Теперь всё ваше приложение имеет доступ к кошельку */}
                   <Component {...pageProps} />
               </WalletModalProvider>
           </WalletProvider>
       </ConnectionProvider>
   );
}

export default MyApp;

Что мы сделали: Мы настроили провайдеры, указав RPC-адрес сети и список поддерживаемых кошельков. autoConnect будет пытаться автоматически подключить кошелек, если пользователь уже давал разрешение.
________________
Шаг 2: Оживление кнопки "Подключить кошелек"
Теперь вы можете использовать готовый компонент кнопки в любом месте вашего сайта. Замените свою кнопку-заглушку на эту.
В вашем компоненте хедера или на главной странице:


JavaScript




import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';

export const Header = () => {
   return (
       <nav>
           {/* ... другие элементы хедера */}
           <WalletMultiButton />
       </nav>
   );
};

Эта кнопка уже умеет всё: показывать "Connect Wallet", открывать модальное окно с выбором кошельков, а после подключения отображать адрес и кнопку для отключения.
________________
ШаГ 3: Чтение данных (адрес и баланс пользователя)
После подключения кошелька нам нужно получить данные пользователя. Для этого используется хук useWallet.


JavaScript




import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { LAMPORTS_PER_SOL } from '@solana/web3.js';
import { useEffect, useState } from 'react';

export const UserProfile = () => {
   const { connection } = useConnection();
   const { publicKey } = useWallet();
   const [balance, setBalance] = useState(0);

   useEffect(() => {
       if (publicKey) {
           // Получаем баланс в лампортах (самая мелкая единица)
           connection.getBalance(publicKey).then(lamports => {
               // Конвертируем в GOR (предполагаем 9 знаков после запятой, как у SOL)
               setBalance(lamports / LAMPORTS_PER_SOL);
           });
       }
   }, [publicKey, connection]);

   if (!publicKey) {
       return <div>Подключите кошелек, чтобы увидеть профиль</div>;
   }

   return (
       <div>
           <p>Ваш адрес: {publicKey.toBase58()}</p>
           <p>Ваш баланс: {balance.toFixed(4)} $GOR</p>
       </div>
   );
};

Что мы сделали: Мы использовали хук useWallet для получения publicKey (адреса) и хук useConnection для получения объекта connection. Как только publicKey появляется, мы делаем RPC-запрос getBalance и обновляем состояние.
________________
Шаг 4: Отправка транзакции ("Накормить монстра")
Это сердце вашего dApp. Вот как выглядит функция, которая будет вызываться при нажатии на кнопку "Накормить".


JavaScript




import { useConnection, useWallet } from '@solana/wallet-adapter-react';
import { PublicKey, SystemProgram, Transaction, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { useCallback } from 'react';

// Адрес вашего "мусорного" кошелька (куда будут уходить токены)
const TRASH_CAN_ADDRESS = new PublicKey('GarbAgeXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'); // !!! ЗАМЕНИТЕ НА СВОЙ АДРЕС !!!

export const FeedButton = () => {
   const { connection } = useConnection();
   const { publicKey, sendTransaction } = useWallet();

   const handleFeedMonster = useCallback(async (amount) => {
       if (!publicKey) {
           alert('Пожалуйста, подключите кошелек!');
           return;
       }

       try {
           // 1. Создаем инструкцию для перевода токенов
           const transaction = new Transaction().add(
               SystemProgram.transfer({
                   fromPubkey: publicKey,
                   toPubkey: TRASH_CAN_ADDRESS,
                   lamports: amount * LAMPORTS_PER_SOL, // Переводим GOR в лампорты
               })
           );

           // 2. Получаем последний blockhash
           const { blockhash } = await connection.getLatestBlockhash();
           transaction.recentBlockhash = blockhash;
           transaction.feePayer = publicKey;

           // 3. Отправляем транзакцию на подпись в кошелек
           const signature = await sendTransaction(transaction, connection);
           console.log('Транзакция отправлена, сигнатура:', signature);

           // 4. (Опционально, но рекомендуется) Ждем подтверждения транзакции
           await connection.confirmTransaction(signature, 'processed');
           console.log('Транзакция подтверждена!');
           alert('Монстр накормлен!');
           
           // !!! ЗДЕСЬ ВЫЗЫВАЕМ ЛОГИКУ РЕФЕРАЛОВ (см. Шаг 6) !!!

       } catch (error) {
           console.error(error);
           alert(`Ошибка при отправке транзакции: ${error.message}`);
       }
   }, [publicKey, sendTransaction, connection]);

   return <button onClick={() => handleFeedMonster(0.1)}>Накормить монстра на 0.1 GOR</button>;
};

Что мы сделали:
1. Создали транзакцию с инструкцией SystemProgram.transfer.
2. Присвоили ей recentBlockhash, чтобы сеть знала, что она свежая.
3. Использовали sendTransaction из useWallet. Именно эта функция вызывает всплывающее окно кошелька для подтверждения.
4. Дождались подтверждения, чтобы дать пользователю обратную связь.
________________
Шаг 5: Интеграция лидерборда
Ваш фронтенд не считает очки. Он просто запрашивает готовый результат у вашего бэкенда.


JavaScript




import { useEffect, useState } from 'react';

export const Leaderboard = () => {
   const [leaders, setLeaders] = useState([]);
   const [isLoading, setIsLoading] = useState(true);

   useEffect(() => {
       // Запрос к вашему API
       fetch('/api/leaderboard') // Убедитесь, что ваш Next.js правильно проксирует этот запрос к бэкенду
           .then(res => res.json())
           .then(data => {
               setLeaders(data);
               setIsLoading(false);
           })
           .catch(err => {
               console.error("Не удалось загрузить лидерборд", err);
               setIsLoading(false);
           });
   }, []);

   if (isLoading) return <p>Загрузка мусорной кучи...</p>;

   return (
       <table>
           <thead>
               <tr>
                   <th>Ранг</th>
                   <th>Адрес</th>
                   <th>Stink-Score</th>
               </tr>
           </thead>
           <tbody>
               {leaders.map((leader, index) => (
                   <tr key={leader.wallet_address}>
                       <td>{index + 1}</td>
                       <td>{leader.wallet_address}</td>
                       <td>{leader.total_score}</td>
                   </tr>
               ))}
           </tbody>
       </table>
   );
};

________________
Шаг 6: Интеграция реферальной системы
Это комбинация работы с URL на фронтенде и отправки данных на бэкенд.
1. Чтение и сохранение реферального кода. В pages/_app.js или в главном компоненте страницы:
JavaScript
import { useRouter } from 'next/router';
import { useEffect } from 'react';

// Внутри вашего компонента MyApp или Index страницы
const router = useRouter();
useEffect(() => {
   const ref = router.query.ref;
   if (ref && typeof ref === 'string') {
       // Сохраняем адрес реферера в localStorage
       localStorage.setItem('referrerAddress', ref);
       console.log(`Сохранен реферер: ${ref}`);
   }
}, [router.query]);

2. Отправка данных на бэкенд после ПЕРВОЙ транзакции. Модифицируем нашу функцию handleFeedMonster:
JavaScript
// ... внутри try блока функции handleFeedMonster, ПОСЛЕ `await connection.confirmTransaction(...)`

// Проверяем, была ли уже регистрация по рефералу
const isReferralRegistered = localStorage.getItem('isReferralRegistered');
const referrerAddress = localStorage.getItem('referrerAddress');

if (referrerAddress && !isReferralRegistered) {
   // Отправляем запрос на наш бэкенд для привязки реферала
   await fetch('/api/register-referral', {
       method: 'POST',
       headers: { 'Content-Type': 'application/json' },
       body: JSON.stringify({
           refereeAddress: publicKey.toBase58(),
           referrerAddress: referrerAddress,
       }),
   });
   // Помечаем, что регистрация прошла, чтобы не слать запрос повторно
   localStorage.setItem('isReferralRegistered', 'true');
   console.log('Реферал успешно зарегистрирован на бэкенде!');
}

Итог: что мы сделали
   1. Настроили WalletProvider: Весь ваш сайт теперь "знает" о существовании кошельков.
   2. Интегрировали кнопку: Заменили заглушку на функциональную кнопку из @solana/wallet-adapter-react-ui.
   3. Научились читать данные: Получаем и отображаем адрес и баланс пользователя.
   4. Научились отправлять транзакции: Реализовали основную игровую механику — "кормление монстра".
   5. Подключили данные для лидерборда: Загружаем и отображаем данные с вашего бэкенд-API.
   6. Реализовали реферальную логику: Сохраняем код реферера и отправляем данные на бэкенд после первой транзакции.
Теперь ваш визуальный MVP превратился в полноценный, работающий dApp. Следующие шаги — это улучшение UX (добавление лоадеров, сообщений об успехе/ошибке) и финальное тестирование.